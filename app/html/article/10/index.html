<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用lambda在Ruby里模仿实现JS的对象及原型继承</title>
	<link rel="stylesheet" href="/stylesheets/style.css">
</head>
<body>
	<div class="main wrap">
		<header>
			<h1><a href="/">Mabinogion</a></h1>
			<p>for Fiodh, love and peace</p>
			<nav>
				<ul>
					<li><a href="/">Home</a></li>/
					<li><a href="/article/1">About</a></li>/
					<li><a href="/category/1">Emotion</a></li>/
					<li><a href="/category/2">Tech</a></li>/
					<li><a href="/category/3">Sophie</a></li>/
					<li><a href="http://fsk.im/music" target="_blank">Music</a></li>
				</ul>
			</nav>
		</header>
				<article>
			<h2 class="article-title">使用lambda在Ruby里模仿实现JS的对象及原型继承</h2>
			<p class="article-date">December 15th, 2014 00:35</p>
			<div class="article-body">
				<p>ruby没有对原型模式的支持实在是有些遗憾，虽然Matz在书里说可以通过object.clone实现原型，但这只是看上去像而已，实际上并不会形成一条原型链。</p>

<pre><code>a.attr = 10
b = a.clone
a.attr = 9
b.attr             # =&gt; 10
</code></pre>

<p>clone可以使b有和a一样的属性，但b拥有的是属性的拷贝，即使a的属性改变了，也不会对b有影响，这不符合原型链的定义。按原型链继承的对象，如果没有某属性，应当沿着原型链向上搜寻，找原型的属性替代。</p>

<p>要在ruby实现原型链我首先想到是使用对象的单件类，但是单件类不允许new也不允许继承，甚至连方法都不能解绑换绑到别的对象上。接着我考虑借助ruby的类继承，因为类继承和原型继承是非常相似的，然而很快遇到了问题，js里原型是可以随意更换的，而ruby的类在定义的时候就要确定继承关系，之后无法更改父类，所以这个想法也不可行。</p>

<p>于是考虑自己实现继承的功能，每个对象设置一个prototype属性，当获取属性时，如果属性在当前对象不存在，则会去prototype指向的对象内查找，一层一层递进，直到prototype为nil。</p>

<p><a href="https://github.com/CicholGricenchos/tricks/blob/master/prototype/using_ruby_object.rb">https://github.com/CicholGricenchos/tricks/blob/master/prototype/using_ruby_object.rb</a></p>

<p>借助ruby本身的对象系统，很容易就实现了一个。其中对象的方法是用lambda存储的，而lambda会在创建时和周围的上下文绑定在一起，而给对象设置属性的时候，这些lambda都是在对象外创建的。为了让这些lambda能操作对象内部，必须重新设置上下文，这里我使用了instance_eval，把绑定设在实例以内。</p>

<p>不过观察js对象的函数，只会设置一个this指针，并不会改变上下文，这个ruby版本虽然功能大致实现了，但实现得还不好，不够geek。接着我想能不能不借助Object，单纯用闭包实现一个呢？</p>

<p><a href="https://github.com/CicholGricenchos/tricks/blob/master/prototype/using_pure_lambda.rb">https://github.com/CicholGricenchos/tricks/blob/master/prototype/using_pure_lambda.rb</a></p>

<p>这是最终实现的代码，思路是用一个闭包表示一个对象，闭包内有个variables hash存储对象的属性，然后暴露一个lambda用于提供get set操作，也就是代码里的handler。</p>

<p>这个handler可以接受两个参数，属性名称和属性值，如果只提供名称，则为get操作，返回这个属性的值，如果二者都提供，则为set，将属性设为给定的值。</p>

<p>PS：lambda[*arg] 以及 lambda.(*arg)是调用的语法糖，等价于lambda.call(*arg)。</p>

<p>实践的时候很快就遇到了麻烦，还是lambda上下文的问题，在对象外创建的lambda读取不了对象的variables。我一开始想参照前一版的做法，把lambda的binding改到对象内，但发现不使用instance_eval之类是做不到的。尝试了诸如重新创建lambda的办法，都失败了。</p>

<p>摸索的过程记在了 <a href="https://ruby-china.org/topics/23160">https://ruby-china.org/topics/23160</a></p>

<p>后来突然想到，如果不能转换上下文，不如把需要用到的量通过eval插入到lambda的上下文里，相当于构造一个上下文，也能达到目的。最直观的想法就是让lambda的上下文有个指向对象自身的this，这和js的做法也很相似，之后就可以通过this[:attr]来读取自身的属性。</p>

<p>一开始我是用 <code>eval &quot;this = #{对象名称}&quot;, lambda.binding</code> 的形式进行插入的，因为eval只能接收字符串代码，所以我必须知道对象的名称才能让this指向它。但是对象可以随时在不同名称的变量中转移，要记录变量的名称很不现实，如果可以把handle传进lambda的binding就好了。</p>

<p>想了很久，跨作用域传递一个量看上去是不可能的，不过有些变量是每个域都可以访问的，就是全局变量，通过全局变量可以让两个毫不相关的上下文进行通信。于是我把handler放到一个全局变量里，再eval一个this方法（至于为什么是方法，可以参照ruby-china那个帖子），指向这个全局变量，问题就解决了。</p>

<p>后面我把这个流程封装到pack_lambda里，这个lambda的作用是在对象方法执行前插入this指针，执行方法，然后再置空this，返回方法的返回值。还顺便提供了一个构造函数的机制。</p>

<p>现在对象的方法lambda和js函数的行为是一致的，拥有一个指向对象自身的this指针，所有操作都通过这个this完成，而上下文环境不会改变，同时很好地实现了原型继承功能，目标达成了。 </p>

			</div>
		</article>
		<footer>
			<img src="/stylesheets/3.png">
		</footer>
	</div>
</body>
</html>